import streamlit as st
import json
from pathlib import Path
from typing import Dict, Any, List
import time

from canvas_api import (
    add_to_module,
    create_new_quiz,
    BASE, H,
    get_new_quiz_items,      # ✅ used below
    publish_assignment,       # ✅ used below
    assignment_url,           # ✅ used below
    update_new_quiz_item      # ✅ used in Repair block
)
from new_quiz_items import NewQuizItemBuilder, post_new_quiz_item, SUPPORTED_TYPES
from quiz_tag_parser import QuizTagParser
from storyboard import load_storyboard_text

st.set_page_config(page_title="Canvas API Uploader (New Quizzes)", layout="wide")

st.title("Canvas New Quizzes Uploader (All Item Types)")

with st.sidebar:
    st.header("Canvas Settings")
    canvas_domain = st.text_input("Canvas domain (no protocol)", placeholder="your.instructure.com")
    canvas_token = st.text_input("Canvas Access Token", type="password")
    course_id = st.text_input("Course ID", placeholder="12345")
    module_id = st.text_input("Module ID (optional, for Add to Module)", placeholder="67890")
    st.markdown("---")
    st.caption("This app supports New Quizzes via /api/quiz/v1 and Quiz Items API.")
    st.caption("Question types: " + ", ".join(sorted(SUPPORTED_TYPES)))

tab1, tab2 = st.tabs(["Upload Storyboard", "Quick Test"])

def _ensure_items(canvas_domain, course_id, assignment_id, expected_count, token, poll_secs=6, attempts=6):
    from canvas_api import get_new_quiz_items
    last = None
    for _ in range(attempts):
        status, data = get_new_quiz_items(canvas_domain, course_id, assignment_id, token)
        if isinstance(data, list) and len(data) >= expected_count:
            return True, data
        last = (status, data)
        time.sleep(poll_secs)
    return False, last

def _repost_missing(canvas_domain, course_id, assignment_id, qs, have_items, token):
    from new_quiz_items import NewQuizItemBuilder, post_new_quiz_item
    existing_by_pos = {int(it.get("position", 0)): it for it in have_items} if isinstance(have_items, list) else {}
    intended_positions = set(range(1, len(qs) + 1))
    missing_positions = [p for p in sorted(intended_positions) if p not in existing_by_pos]
    builder = NewQuizItemBuilder()
    results = []
    for pos in missing_positions:
        payload = builder.build_item(qs[pos - 1])
        r = post_new_quiz_item(canvas_domain, course_id, assignment_id, payload, token, position=pos)
        try:
            body = r.json()
        except Exception:
            body = r.text
        results.append({"pos": pos, "status": getattr(r, "status_code", None), "body": body})
    return results

with tab1:
    st.subheader("Upload Storyboard (.docx or .txt)")
    up = st.file_uploader("Upload a storyboard file", type=["docx", "txt"])
    if up is not None:
        raw_text = load_storyboard_text(up)
        st.text_area("Raw storyboard (detected)", raw_text, height=200)
        pages = raw_text.split("</canvas_page>")
        pages = [p + "</canvas_page>" for p in pages if "<canvas_page>" in p]
        st.write(f"Detected {len(pages)} <canvas_page> block(s).")

        for i, block in enumerate(pages, start=1):
            with st.expander(f"Canvas Page #{i}"):
                st.code(block, language="xml")

                # Detect a quiz block
                if "<quiz_start>" in block.lower():
                    st.info("Quiz block detected in this page.")
                    parser = QuizTagParser()
                    out = parser.parse(block)
                    qs = out.get("questions", [])
                    st.write(f"Parsed {len(qs)} question(s).")
                    st.json(out)

                    colA, colB = st.columns(2)
                    with colA:
                        quiz_title = st.text_input(f"Quiz Title (Page #{i})", f"Quiz from Page {i}", key=f"title_{i}")
                    with colB:
                        description = st.text_area(
                            f"Quiz Description (Page #{i})",
                            "Generated by API Uploader",
                            key=f"desc_{i}"
                        )

                    if st.button(f"Create & Upload New Quiz for Page #{i}", key=f"upload_{i}"):
                        # ------------ validation ------------
                        if not (canvas_domain and canvas_token and course_id):
                            st.error("Canvas settings are required in the sidebar.")
                            st.stop()

                        if len(qs) == 0:
                            st.error("Parsed 0 questions. Make sure each question is wrapped in <question>...</question> and the quiz ends with </quiz_end> or </quiz>.")
                            st.stop()

                        # ------------ create quiz ------------
                        created = create_new_quiz(canvas_domain, course_id, quiz_title, description, canvas_token)

                        # Safe guard if create failed or returned None
                        if not created or not created.get("assignment_id"):
                            st.error("Create New Quiz did not return an assignment_id.")
                            st.caption("Canvas response attempts:")
                            st.code(json.dumps((created or {}).get("http_debug", {}), indent=2), language="json")
                            st.stop()

                        assignment_id = created["assignment_id"]

                        # ------------ post items ------------
                        builder = NewQuizItemBuilder()
                        success_ct = 0
                        failures = []

                        for pos, q in enumerate(qs, start=1):
                            try:
                                payload = builder.build_item(q)
                                resp = post_new_quiz_item(
                                    canvas_domain, course_id, assignment_id, payload, canvas_token, position=pos
                                )
                                try:
                                    body = resp.json()
                                except Exception:
                                    body = resp.text
                                if resp.status_code in (200, 201):
                                    success_ct += 1
                                else:
                                    failures.append({"position": pos, "status": resp.status_code, "body": body})
                            except Exception as e:
                                failures.append({"position": pos, "status": "client-exception", "body": str(e)})

                        # Verify what Canvas thinks is in the quiz
                        st.success(f"New Quiz created. {success_ct}/{len(qs)} item requests succeeded. (assignment_id={assignment_id})")

                        status_code, items_data = get_new_quiz_items(canvas_domain, course_id, assignment_id, canvas_token)
                        st.caption(f"Items GET status: {status_code}")
                        st.code(json.dumps(items_data, indent=2), language="json")

                        # Publish so it’s visible in Modules/Assignments immediately
                        if publish_assignment(canvas_domain, course_id, assignment_id, canvas_token):
                            st.success("Assignment published.")
                        else:
                            st.warning("Could not publish assignment (you can publish it manually).")

                        st.markdown("---")
                        if st.button("Repair quiz (re-fetch, re-post missing, nudge items)"):
                            # a) fetch what Canvas actually has
                            status_code, items_data = get_new_quiz_items(canvas_domain, course_id, assignment_id, canvas_token)
                            st.caption(f"Items GET status: {status_code}")
                            st.code(json.dumps(items_data, indent=2), language="json")

                            # b) figure out which positions we intended to have
                            intended_positions = set(range(1, len(qs) + 1))
                            existing_by_pos = (
                                {int(it.get("position", 0)): it}
                                if not isinstance(items_data, list)
                                else {int(it.get("position", 0)): it for it in items_data}
                            )
                            missing_positions = [p for p in sorted(intended_positions) if p not in existing_by_pos]

                            # c) re-post any missing items
                            readd_results = []
                            builder = NewQuizItemBuilder()
                            for pos in missing_positions:
                                try:
                                    payload = builder.build_item(qs[pos - 1])
                                    r = post_new_quiz_item(
                                        canvas_domain, course_id, assignment_id, payload, canvas_token, position=pos
                                    )
                                    try:
                                        body = r.json()
                                    except Exception:
                                        body = r.text
                                    readd_results.append({"pos": pos, "status": r.status_code, "body": body})
                                except Exception as e:
                                    readd_results.append({"pos": pos, "status": "client-exception", "body": str(e)})
                            if readd_results:
                                st.write("Reposted missing item results:")
                                st.code(json.dumps(readd_results, indent=2), language="json")

                            # d) "nudge" each existing item with a no-op update to force a refresh
                            nudge_results = []
                            if isinstance(items_data, list):
                                for pos, it in sorted(existing_by_pos.items()):
                                    item_payload = {
                                        "item": {
                                            "id": it["id"],
                                            "position": it.get("position"),
                                            "points_possible": it.get("points_possible", 1.0),
                                            "entry_type": "Item",
                                            "entry": it["entry"],  # send back exactly what server has
                                        }
                                    }
                                    r = update_new_quiz_item(
                                        canvas_domain, course_id, assignment_id, it["id"], item_payload, canvas_token
                                    )
                                    try:
                                        body = r.json()
                                    except Exception:
                                        body = r.text
                                    nudge_results.append({"pos": pos, "status": r.status_code, "body": body})
                                st.write("Nudge results:")
                                st.code(json.dumps(nudge_results, indent=2), language="json")

                            # e) publish and give a direct link (less likely to hang than the inline Build iframe)
                            if publish_assignment(canvas_domain, course_id, assignment_id, canvas_token):
                                st.success("Assignment published.")

                                # Verify & auto-heal
                            ok, items_or_last = _ensure_items(canvas_domain, course_id, assignment_id, len(qs), canvas_token)
                            if not ok:
                                st.warning("Items service didn’t return all items yet; attempting auto-repair…")
                                readded = _repost_missing(canvas_domain, course_id, assignment_id, qs, items_or_last[1], canvas_token)
                                st.code(json.dumps(readded, indent=2), language="json")
                                # poll again after re-post
                                ok2, items_or_last2 = _ensure_items(canvas_domain, course_id, assignment_id, len(qs), canvas_token, poll_secs=4, attempts=4)
                                st.caption(f"Post-repair GET status: {items_or_last2[0] if not ok2 else 'OK'}")
                                st.code(json.dumps(items_or_last2 if ok2 else items_or_last2[1], indent=2), language="json")
                            else:
                                st.caption("Items present on server:")
                                st.code(json.dumps(items_or_last, indent=2), language="json")

                            st.markdown(f"[Open in Canvas]({assignment_url(canvas_domain, course_id, assignment_id)})")

                        # Direct link to open it in Canvas (use this instead of the spinning Build route)
                        st.markdown(f"[Open in Canvas]({assignment_url(canvas_domain, course_id, assignment_id)})")

                        # Show any failures (e.g., 5xx that persisted)
                        if failures:
                            st.warning("Some items failed to add:")
                            st.code(json.dumps(failures, indent=2), language="json")

with tab2:
    st.subheader("Try a Minimal Example")
    example = """<canvas_page>
<quiz_start>
<question><multiple_choice><no_shuffle>
What is 2 + 2?
* 4 <feedback> Correct
3 <feedback> Off by one
5 <feedback> Too high
</question>

<question><true_false>
The sky is blue.
correct: True
</question>

<question><short_answer>
Name a primary color.
answers:
Red
Blue
Yellow
</question>

<question><numeric>
What is the speed (m/s)?
exact: 12.5
tolerance: 0.5
</question>

<question><matching>
Match the chemical to its common name.
pairs:
H2O => Water
NaCl => Salt
</question>

<question><ordering>
Order the stages:
order:
First
Second
Third
</question>

<question><categorization>
Sort animals:
category Mammals:
Dog
Cat
category Birds:
Eagle
Sparrow
</question>

<question><fill_in_blank>
Water formula: H{{b1}}O is {{b2}}.
blank b1:
  - 2
blank b2:
  - water
</question>
</quiz_end>
</canvas_page>"""
    st.code(example, language="xml")
    st.caption("Paste this into a .txt file to test.")
